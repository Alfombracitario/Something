<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Freakein epirk text ER PI GI</title>
  <style>
    :root {
      --terminal-bg: #000;
      --terminal-text: #0f0;
      --terminal-aspect: 4/3;
      --button-bg: #333;
      --button-active: #555;
      --button-text: #fff;
      --button-size: 64px;
      --button-gap: 8px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
      user-select: none;
    }

    body {
      background: #111;
      height: 100vh;
      width: 100vw;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }

    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 15px;
    }

    body.desktop #game-container {
      gap: 0;
    }

    #terminal {
      background: var(--terminal-bg);
      color: var(--terminal-text);
      padding: 15px;
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      aspect-ratio: var(--terminal-aspect);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: stretch;
      width: 100%;
      max-height: 100%;
      max-width: calc(100vh * (4 / 3));
    }

    #terminal-content {
      white-space: pre;
      word-break: break-word;
      overflow: auto;
      width: 100%;
      height: 100%;
      font-family: inherit;
    }

    #controls {
      padding: 5px 0 15px;
    }

    body.desktop #controls {
      display: none;
    }

    .button-row {
      display: flex;
      justify-content: center;
      gap: var(--button-gap);
      margin-bottom: var(--button-gap);
    }

    .button-cell {
      flex: 1;
      display: flex;
      justify-content: center;
      max-width: calc(var(--button-size) * 1.5);
    }

    .btn {
      width: var(--button-size);
      height: var(--button-size);
      border-radius: 50%;
      background: var(--button-bg);
      color: var(--button-text);
      border: 2px solid #000;
      font-size: 24px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.1s;
      box-shadow: 0 4px 0 rgba(0,0,0,0.3);
    }

    .btn:active {
      background: var(--button-active);
      transform: translateY(4px);
      box-shadow: 0 1px 0 rgba(0,0,0,0.3);
    }

    #btn-up::after    { content: "↑"; }
    #btn-down::after  { content: "↓"; }
    #btn-left::after  { content: "←"; }
    #btn-right::after { content: "→"; }
    #btn-a::after     { content: "A"; }
    #btn-b::after     { content: "B"; }
    #btn-1::after     { content: "1"; }
    #btn-2::after     { content: "2"; }
    #btn-select::after{ content: "SEL"; font-size: 16px; }
    #btn-start::after { content: "STA"; font-size: 16px; }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="terminal">
      <div id="terminal-content">
Welcome to the Wii-style terminal!
This font size adjusts to always show 80×30 characters.
      </div>
    </div>
    <div id="controls">
      <div class="button-row"><div class="button-cell"><div id="btn-up" class="btn"></div></div></div>
      <div class="button-row">
        <div class="button-cell"><div id="btn-left" class="btn"></div></div>
        <div class="button-cell"><div id="btn-down" class="btn"></div></div>
        <div class="button-cell"><div id="btn-right" class="btn"></div></div>
      </div>
      <div class="button-row">
        <div class="button-cell"><div id="btn-a" class="btn"></div></div>
        <div class="button-cell"><div id="btn-b" class="btn"></div></div>
      </div>
      <div class="button-row">
        <div class="button-cell"><div id="btn-1" class="btn"></div></div>
        <div class="button-cell"><div id="btn-2" class="btn"></div></div>
      </div>
      <div class="button-row">
        <div class="button-cell"><div id="btn-select" class="btn"></div></div>
        <div class="button-cell"><div id="btn-start" class="btn"></div></div>
      </div>
    </div>
  </div>

  <script>
    // Detectar si es PC
    const isDesktop = () => !/android|iphone|ipad|ipod|mobile|tablet|touch/i.test(navigator.userAgent);
    if (isDesktop()) {
      document.body.classList.add("desktop");
    }

    // Ajustar fuente para simular 80x30 terminal
    function adjustFontSize() {
      const terminal = document.getElementById("terminal");
      const content = document.getElementById("terminal-content");

      if (!terminal || !content) return;

      const cols = 80;
      const rows = 30;

      const width = terminal.clientWidth;
      const height = terminal.clientHeight;

      const charWidth = width / cols;
      const charHeight = height / rows;

      const fontSize = Math.min(charWidth, charHeight);
      content.style.fontSize = fontSize + "px";
      content.style.lineHeight = "1.0";
    }

    // Ejecutar al cargar y al redimensionar
    window.addEventListener("load", adjustFontSize);
    window.addEventListener("resize", adjustFontSize);
  </script>
</body>
</html>


<script>
// FREAKIN' TEXT RPG 2!!!
// Sistema de escenas modular (state machine) para JS - funciones unificadas en cada escena

document.addEventListener('DOMContentLoaded', () => {
  // ——— Terminal ———
  const termEl = document.getElementById('terminal-content');
  const tline = "------------------";

  // ——— Textos dinámicos ———
  let sanity = "insane";
  let textLV = "Level";
  let textMagic = "Magic";
  let textMP = "MP";
  let textManaPot = "Mana potion";
  function printf(text) {
    termEl.textContent += text;
    termEl.scrollTop = termEl.scrollHeight;
  }
  function clearScreen() {
    termEl.textContent = '';
  }

  // ——— Variables globales de juego ———
  let hp = 10, level = 1, xp = 0, xpNeed = 100, money = 0, mp = 10; defense = 0; damage = 1; skill = 1; maxhp = 10;
  let inventory = [{ name: textManaPot, damage: 5, price: 5 }];
  let invCount = 1;
  let place = "forest";

  // Constantes de lugares
  const Places = {
    forest: {
      name: "Forest",
      enemies: ["evilwizard"]
    },
    city: {
      name: "City",
      enemies: ["trashcan"]
    },
    shop: {
      name: "Shop",
      enemies: []
    },
    cave: {
      name: "Cave",
      enemies: []
    }
  };
  // Lugares conocidos ahora son claves del objeto Places
  let known_places = ["forest"];
  // Enemigos
const ENEMIES = {
    trashcan: {
      names: {
        normal: "Trash can",
        insane: "Armored dwarf"
      },
      hp: 45,
      atk: 2,
      helpercent : 1,
      dialog: {
        normal: {
          intro: [
            "A trash can!"
          ],
          hurt: [
            "plonk"
          ],
          lowHp: [
            "PLONK!!"
          ],
          death: [
            "destroyed trashcan sounds"
          ],
          spare: [
            "...This is awkward"
          ],
          help: [
            "You clean the trash, you are a good person"
          ],
          attack: [
            "..."
          ]
        },
        insane: {
          intro: [
            "You found a armored dwarft with a bag of stolen goods.",
          ],
          hurt: [
            "My armor is inpenetrable, you cannot hurt me",
            "I dont need to run, because my armor is the best armor that has ever existed",
            "You will never get the loot that i stole"
          ],
          lowHp: [
            "What... My armor it's supposed to be indestructible",
            "(nervous) You should stop, your attacks are not dealing any damage",
            "your attacks will never work",
            "I AM INMORTAL"
          ],
          death: [
            "But..... my armor...",
            "You will never...",
            "At least you cant use my armor"
          ],
          spare: [
            "So you now realize you cant inflict damage to me",
          ],
          help: [
            "Ok, i will let you carry my stuff"
          ],
          attack: [
            "Only I can steal from weak people like you, knight.",
            "Not because you're poor you can steal my stuff, that's my work!",
            "Not becuase I steal I'll hurt you."
          ]
        }
      }
    },
  slime: {

  },
  evilwizard: {
    names: {
      normal: "Homeless",
      insane: "Evil Wizard"
    },
    hp: 45,
    atk: 2,
    helpercent : 1,
    dialog: {
      normal: {
        intro: [
          "Hey, I'm starving, I want to end this pain",
          "Why are you looking at me like that?",
          "This isn't how I imagined my last day..."
        ],
        hurt: [
          "What's wrong with you?!",
          "When I said I wanted to end my pain, I didn't mean that!",
          "You monster! That HURTS!"
        ],
        lowHp: [
          "Please, STOP! This hurts!",
          "No more... no more...",
          "I was just hungry..."
        ],
        death: [
          "I didn't mean...",
          "So cold...",
          "You win..."
        ],
        spare: [
          "You didn't helped me.",
          "Why... would you let me go?",
        ],
        help: [
          "Thanks, you're so nice.",
          "Are you really going to help me after that?"
        ],
        attack: [
          "I don't trust you."
        ]
      },
      insane: {
        intro: [
          "The evil wizard approaches.",
        ],
        hurt: [
          "Pain makes me real.",
          "You don't expect my next attack.",
          "You don't scare me, weak knight."
        ],
        lowHp: [
          "You're scaring me.",
          "The colors taste like metal now.",
          "I know your secret.",
          "Stop, STOP",
          "I'll kill you!"
        ],
        death: [
          "You defeated me, but you won't kill the master.",
          "Your scream joins his song.",
          "I'll fade into ink."
        ],
        spare: [
          "You're a disappointment. You'll never be a true knight.",
        ],
        help: [
          "I can't believe you're helping me... that's so cowardly of you. "
        ],
        attack: [
          "You will never be able to grasp the true of the evil wizards."
        ]
      }
    }
  }
};
//funciones para peleas
function randomDialog(part) {
  const lines = currentEnemy.dialog[part];
  if (!lines) return "[...]";
  if (Array.isArray(lines)) {
    return lines[irng(0, lines.length - 1)];
  } else {
    return lines; // fallback si accidentalmente es un string
  }
}

function getEnemy(enemyId) {
  const base = ENEMIES[enemyId];
  if (!base) {
    console.error("Enemy not found:", enemyId);
    return null;
  }

  const state = sanity; // "normal" o "insane"

  return {
    id: enemyId,
    name: base.names[state] || base.names.normal || "???",
    maxHp: base.hp,
    hp: base.hp,
    atk: base.atk,
    dialog: base.dialog[state],
    
    // Accede con: currentEnemy.say("intro") → devuelve línea aleatoria
    say(part) {
      const lines = this.dialog[part];
      if (!lines) return "[...]";
      if (Array.isArray(lines)) {
        return lines[irng(0, lines.length - 1)];
      }
      return lines;
    }
  };
}

  // ——— Input Handling ———
  let lastInput = null, previousKey = null;
  const keyMap = { ArrowUp:'U', ArrowDown:'D', ArrowLeft:'L', ArrowRight:'R', Enter:'+', ' ':'-', z:'A', x:'B', s:'1', a:'2' };
  document.addEventListener('keydown', e => {
    const code = keyMap[e.key];
    if (code && code !== previousKey) { lastInput = code; previousKey = code; }
  });
  document.addEventListener('keyup', e => {
    const code = keyMap[e.key]; if (code === previousKey) previousKey = null;
  });
  const btnMap = { 'btn-up':'U','btn-down':'D','btn-left':'L','btn-right':'R','btn-start':'+','btn-select':'-','btn-a':'A','btn-b':'B','btn-1':'1','btn-2':'2' };
  Object.entries(btnMap).forEach(([id, code]) => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('click', () => {
      if (code !== previousKey) {
        lastInput = code;
        previousKey = code;
        setTimeout(() => previousKey = null, 100);
      }
    });
  });

  // ——— Función auxiliar: formatea lista en columnas con flecha en índice ———
  function formatList(items, sel, cols) {
    // Sistema column-first: llena columnas antes de filas.
    const rows = Math.ceil(items.length / cols);
    let output = '';
    for (let r = 0; r < rows; r++) {
      let line = '';
      for (let c = 0; c < cols; c++) {
        const idx = r + c * rows;
        if (idx < items.length) {
          const prefix = (idx === sel) ? '> ' : '  ';
          let txt = items[idx];
          while (txt.length < 8) txt += ' ';
          line += prefix + txt;
        }
      }
      output += line.trimEnd() + '\n';
    }
    return output;
  }

  // ——— Sistema de escenas ———
  const scenes = {
    intro: {
      enter() {
        clearScreen();
        printf("FREAKIN' TEXT RPG 2!!! | Alfombracitarioj\n\n");
        printf("Long ago, there were knights, wizards, witches, and legends — tales of monsters lurking in the dark...\n\n");
        printf("The knights, driven by glory and honor, held back the darkness for a time. But as the centuries passed, the legends faded. The monsters, however, remained — hiding in plain sight, their faces changed, their presence ignored.\n\n");
        printf("Now, you, the last knight, have seen the truth. And whether it is madness or destiny, you know your purpose: take up the mantle, write your own legend, and stand against the shadows that still haunt this world.\n\n");
        printf("-[Press any key to start]\n");
      },
      update(input) {
        if (input) {
          currentScene = scenes.menu;
          currentScene.enter();
        }
      }
    },

    menu: {
      selected: 0,
      options: ["Inv","Explore","Stats","Rest"],
      cols: 2,
      enter() {
        this.selected = 0;
        this.render();
      },
      update(input) {
        const n = this.options.length;
        if (input === 'L') this.selected = (this.selected + this.cols) % n;
        if (input === 'R') this.selected = (this.selected - this.cols + n) % n;
        if (input === 'U' && this.selected % this.cols === 1) this.selected--;
        if (input === 'D' && this.selected % this.cols === 0 && this.selected + 1 < n) this.selected++;
        if (input === 'A' || input === '2') {
          switch (this.selected) {
            case 0: currentScene = scenes.inventory; break;
            case 1: currentScene = scenes.explore; break;
            case 2: currentScene = scenes.stats; break;
            case 3: currentScene = scenes.rest; break;
          }
          currentScene.enter();
          return;
        }
        this.render();
      },
      render() {
        clearScreen();
        printf("FREAKIN' TEXT RPG 2!!! | Alfombracitarioj\n\n");
        printf(tline+"\n");
        printf(formatList(this.options, this.selected, this.cols));
        printf(tline+"\n");
      }
    },

    inventory: {
      enter() {
        clearScreen();
        printf("[Inventory]\n");
        for (let i = 0; i < invCount; i++) {
          printf("|" + inventory[i].name + "\n");
        }
      },
      update(input) {
        if (input === 'B') { currentScene = scenes.menu; currentScene.enter(); }
      }
    },

    stats: {// [ESCENA ESTADÍSTICAS]
        selected : 0,
        options : ["Max HP: ["+maxhp+"]","Base damage: ["+damage+"]","Base defense: ["+defense+"]","Exit >"],
        cols : 1,
      render(){
        clearScreen();
        printf(tline+"\n");
        printf("[Statistics]\n");
        printf(tline+"\n");
        printf("|HP: ["+hp+"]|\n");
        printf("|"+textMP+": ["+mp+"]|\n");
        printf("|Knight Level: ["+level+"] - XP:"+((xp/xpNeed)*100).toFixed(0)+"%|\n");
        printf("|Money: [$"+money+"]|");

        printf("\n"+tline);
        printf("\n[Skills]\n");
        printf("|Skill points: ["+skill+"]\n");
        this.options = ["Max HP: ["+maxhp+"]","Base damage: ["+damage+"]","Base defense: ["+defense+"]","Exit >"]; //updates the list
        printf(formatList(this.options, this.selected, this.cols));
        printf(tline);
      },
      enter() {
        this.render();
      },
      update(input) {
        if (input === 'B' || input === '1') { currentScene = scenes.menu; currentScene.enter(); }
        if (input === 'U') {
          if(this.selected > 0 ) {this.selected--;}
          this.render();
        }
        if (input === 'D') {
          if(this.selected < 3 ) {this.selected++;}
          this.render();
        }
        if(input === 'A' || input === '2')
        {
          switch(this.selected)
          {
            case 0://Max HP
              if(skill <= 0) {break;}
              maxhp++;
              skill--;
              this.render();
            break;

            case 1://Base damage
              if(skill <= 0) {break;}
              damage++;
              skill--;
              this.render();
            break;

            case 2://Base defense
              if(skill <= 0) {break;}
              defense++;
              skill--;
              this.render();
            break;

            case 3://Exit
              currentScene = scenes.menu;
              currentScene.enter();
            break;
          }
        }
      }
    },
    explore: {
      selected: 0,
      cols: 1,

      get options() {
        const opts = ["Look for something new"];
        for (let i = 0; i < known_places.length; i++) {
          const key = known_places[i];
          opts.push("go to " + Places[key].name);
        }
        return opts;
      },
      render() {
        clearScreen();
        printf("Explore: \n");
        printf(formatList(this.options, this.selected, this.cols));
      },
      enter() {
        this.render();
      },

      update(input) {
        if(input === 'U') {
          this.selected--;
          this.selected = Math.max(this.selected,0);
          this.render();
        }
        if(input === 'D') {
          this.selected++;
          this.selected = Math.min(this.selected, known_places.length);
          this.render();
        }
        if (input === 'A' || input === '2') {
          this.render();
          if(this.selected === 0) {//si selecciona buscar algo nuevo,
            let random = irng(1,10);
            if(random === 1) { //busca un lugar nuevo (10%)
              const allKeys = Object.keys(Places);
              const notKnown = allKeys.filter(k => !known_places.includes(k));
              if(notKnown.length > 0) {
                const newKey = notKnown[irng(0, notKnown.length-1)];
                known_places.push(newKey);
                printf("\nYou found a new place: " + Places[newKey].name + "!\n");
              } else {
                printf("There is nothing more to explore.\n");
              }
            }
            else {// Empieza una pelea en el lugar actual
              currentScene = scenes.fight; currentScene.enter();
            }

          } else {//se eligió ir a otro lugar
            place = known_places[this.selected-1];
            currentScene = scenes.exploring; currentScene.enter();
          }
          
        }
        if (input === 'B') {
          currentScene = scenes.menu;
          currentScene.enter();
        }
      }
    },
    exploring : {
      render() {
        clearScreen();
        printf(place);
      },
      enter() {
          this.render();
      },
      update(input) {
        if (input === 'B' || input === '2') { currentScene = scenes.explore; currentScene.enter(); }
      }
    },

    fight : {
      currentEnemy : 0,
      selected : 0,
      options : ["Attack",textMagic,"Defend","Let Go","Help"],
      cols : 5,
      render()
      {
        clearScreen();
        printf("[Fight]");
        printf("\n"+tline+tline+tline+"\n");
        printf(formatList(this.options, this.selected, this.cols));
        printf(tline+tline+tline+"\n");
        //info del jugador
        printf("HP: "+hp);
        printf("\n"+tline+tline+tline+"\n");
      },
      enter()
      {
        let enemies = Places[place].enemies;
        let enemyId = enemies[irng(0, enemies.length - 1)];
        currentEnemy = getEnemy(enemyId);
        this.render();
        if(currentEnemy) printf(currentEnemy.say("intro"));
      },
      update(input)
      {
        if(input === 'A')
        {
          //primero, el enemigo ataca
          this.render();
          printf("The "+currentEnemy.name+" says:\n   |");
          printf(currentEnemy.say("attack")+"\n");

          printf("You lose: "+currentEnemy.atk+" Hp!\n");
          takeDamage();
          printf(tline+"\n");
          switch(this.selected)
          {
            case 0://attack
              printf("You attack the "+currentEnemy.name+",\nloses: "+damage+"HP!\n");
              currentEnemy.hp -= damage;

              printf(tline+"\n")
              printf("the "+currentEnemy.name+" says:\n   |"+currentEnemy.say("hurt"));
            break;
          }
        }
      },
      draw()
      {

      },
      takeDamage()
      {
        hp-=currentEnemy.atk;
        if(hp < 0)
        {
          printf("You are dead. you lose all your money.");
          money = 0;
        }
      }
    },
    rest: {// [ESCENA REST]
      enter() {
        clearScreen();
        if(hp < maxhp)
        {
          hp++;
          printf("You rest and recover some HP...\n");
        }
        else
        {
          printf("Your health is full!");
        }
        setTimeout(() => { currentScene = scenes.menu; currentScene.enter(); }, 1000);
      },
      update() {}
    }
  };

  // Estado inicial
  let currentScene = scenes.intro;
  currentScene.enter();

  // ——— Bucle de juego (16ms) ———
  setInterval(() => {
    if (lastInput) {
      currentScene.update(lastInput);
      lastInput = null;
    }
  }, 16);

  // ——— Función aleatoria ———
  function irng(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
});

</script>
</body>
</html>